---
title: "check coverage after adding weights, neuron real data, add gamma, cv, reduce fdr"
author: "DongyueXie"
date: "2021-08-18"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

## Introduction

In the neuron real data based [simulation](check_coverage_adding_weights_neuron_real.html), the coverage gets larger when using true $\beta$ for calculating variance.

Here we try to: revise the cross-validation methods, reduce the fdr level to 0.01.

```{r}
indis_ref = readRDS('data/neuron/indis_ref_12400by6by97.rds')
rmse = function(x,y){sqrt(mean((x-y)^2))}
```

```{r,warning=F,message=F}
source('code/deconference_main.R')
source('code/simulation/simu_correlation_ult.R')
```



## revise the cross-validation methods

```{r}

b1 = c(0.1,0.1,0.15,0.15,0.2,0.3)
b2 = c(0.1,0.15,0.25,0.3,0.1,0.1)


n = dim(indis_ref)[3]
n_ref = 11
n_bulk = n-n_ref
b = cbind(b1%*%t(rep(1,n_bulk/2)),b2%*%t(rep(1,n_bulk/2)))

set.seed(12345)
ref.idx = sort(sample(1:n,n_ref))
G = dim(indis_ref)[1]
K = dim(indis_ref)[2]
gene_names = dimnames(indis_ref)[[1]]

X_array_ref = indis_ref[,,ref.idx]
X_array_bulk = indis_ref[,,-ref.idx]

X = apply(X_array_ref,c(1,2),mean,na.rm=TRUE)
V = t(apply(X_array_ref,c(1),function(z){(cov(t(z),use = 'complete.obs'))}))/n_ref
V.temp = t(apply(X_array_ref,c(1),function(z){(cov(t(z),use = 'complete.obs'))}))
fit.vash = vashr::vash(sqrt(rowSums(V.temp)),df=9)
w = 1/(fit.vash$sd.post)^2
summary(w)

bulk_lib_size = 500
mb = lapply(1:n_bulk,function(i){X_array_bulk[,,i]%*%b[,i]})
mb = do.call(cbind,mb)
thetab = apply(mb,2,function(z){z/sum(z)})
true.beta = t(t(b)*c(apply(mb,2,function(z){bulk_lib_size*G/sum(z)})))
y = matrix(rpois(G*n_bulk,bulk_lib_size*G*thetab),nrow=G)
rownames(y) = gene_names


cor.idx = readRDS('data/neuron/gene12400_cor_idx_alpha005.rds')
dim(cor.idx)
```


perform kmeans on row-centered bulk matrix.

```{r}
# folds = kmeans(t(scale(t(y),scale = F)),10,iter.max = 100,algorithm="MacQueen")$cluster
# fit = estimation_func2(y=y,X=X,Vg=V,
#                        w=w,hc.type='jackknife',correction=FALSE,
#                                              calc_cov=F,verbose=T,
#                                              cor.idx=cor.idx,
#                                              centeringXY=F,
#                                              true.beta = NULL,
#                                              only.scale.pos.res=F,
#                                              only.add.pos.res=T,
#                                              folds=folds,
#                                              use_all_pair_for_cov=F)
# saveRDS(fit,file='output/check_coverage_weight_neuron/11ref_jackknife_kmeans_centered_alpha005_add_pos_res.rds')

fit = readRDS('output/check_coverage_weight_neuron/11ref_jackknife_kmeans_centered_alpha005_add_pos_res.rds')


boxplot(t(fit$p_hat_se[,1:n_bulk/2]),ylim = range(c(fit$p_hat_se[,1:n_bulk/2],apply(fit$p_hat[,1:n_bulk/2],1,sd,na.rm=T)),na.rm = T),
        main = 'cor,cross validation')
lines(apply(fit$p_hat[,1:n_bulk/2],1,sd),type='p',col='yellow',pch=17)
legend('bottomright',c('true sd'),pch=17,col='yellow')

waldi = (fit$p_hat-b)/fit$p_hat_se

rowMeans(abs(waldi)<=1.96,na.rm = T)

rmse(fit$p_hat[,1:(n_bulk/2)],b[,1:(n_bulk/2)])
```


perform kmeans on row-centered and scaled bulk matrix.

```{r}
# folds = kmeans(t(scale(t(y))),10,iter.max = 100,algorithm="MacQueen")$cluster
# fit = estimation_func2(y=y,X=X,Vg=V,
#                        w=w,hc.type='jackknife',correction=FALSE,
#                                              calc_cov=F,verbose=T,
#                                              cor.idx=cor.idx,
#                                              centeringXY=F,
#                                              true.beta = NULL,
#                                              only.scale.pos.res=F,
#                                              only.add.pos.res=T,
#                                              folds=folds,
#                                              use_all_pair_for_cov=F)

# saveRDS(fit,file='output/check_coverage_weight_neuron/11ref_jackknife_kmeans_centered_scaled_alpha005_add_pos_res.rds')

fit = readRDS('output/check_coverage_weight_neuron/11ref_jackknife_kmeans_centered_scaled_alpha005_add_pos_res.rds')

boxplot(t(fit$p_hat_se[,1:n_bulk/2]),ylim = range(c(fit$p_hat_se[,1:n_bulk/2],apply(fit$p_hat[,1:n_bulk/2],1,sd,na.rm=T)),na.rm = T),
        main = 'cor,cross validation')
lines(apply(fit$p_hat[,1:n_bulk/2],1,sd),type='p',col='yellow',pch=17)
legend('bottomright',c('true sd'),pch=17,col='yellow')

waldi = (fit$p_hat-b)/fit$p_hat_se

rowMeans(abs(waldi)<=1.96,na.rm = T)

rmse(fit$p_hat[,1:(n_bulk/2)],b[,1:(n_bulk/2)])
```

alternatively, try to use hierarchical clustering based on correlations.

Firstly, we create a distance matrix based on the correlation index from multiple testing.

```{r}
# construct distance matrix, 
# if correlated, distance = 0, otherwise, correlation = 1

R01 = sparseMatrix(i = cor.idx[,1],j = cor.idx[,2],dims = c(G,G))
diag(R01) = 1
R01 = as.dist(1-R01)
hc = hclust(R01,method = 'centroid')
folds = cutree(hc,k=10)
table(folds)
```

This does not work because almost all genes are in 1 cluster.

Or, we directly use the correlation matrix.

```{r}
day30bulk = readRDS("data/neuron/day30bulk.rds")
gene_name_12400 = readRDS('data/neuron/gene_name_12400.rds')
bulk = day30bulk[match(gene_name_12400,rownames(day30bulk)),]

library(Rfast)
R = cora(t(bulk))
R = as.dist(1-abs(R))
hc = hclust(R,method = 'centroid')
folds = cutree(hc,k=10)
table(folds)
```

Still does not work.

Alternatively, we can run k medoids methods on the distance matrix from correlations. 


```{r}
library(cluster)
clusters = pam(R,10)
folds = clusters$clustering
table(folds)
```

```{r}

# fit = estimation_func2(y=y,X=X,Vg=V,
#                        w=w,hc.type='jackknife',correction=FALSE,
#                                              calc_cov=F,verbose=T,
#                                              cor.idx=cor.idx,
#                                              centeringXY=F,
#                                              true.beta = NULL,
#                                              only.scale.pos.res=F,
#                                              only.add.pos.res=T,
#                                              folds=folds,
#                                              use_all_pair_for_cov=F)
# 
# saveRDS(fit,file='output/check_coverage_weight_neuron/11ref_jackknife_kmedoids_alpha005_add_pos_res.rds')

fit = readRDS('output/check_coverage_weight_neuron/11ref_jackknife_kmedoids_alpha005_add_pos_res.rds')

boxplot(t(fit$p_hat_se[,1:n_bulk/2]),ylim = range(c(fit$p_hat_se[,1:n_bulk/2],apply(fit$p_hat[,1:n_bulk/2],1,sd,na.rm=T)),na.rm = T),
        main = 'cor,cross validation')
lines(apply(fit$p_hat[,1:n_bulk/2],1,sd),type='p',col='yellow',pch=17)
legend('bottomright',c('true sd'),pch=17,col='yellow')

waldi = (fit$p_hat-b)/fit$p_hat_se

rowMeans(abs(waldi)<=1.96,na.rm = T)

rmse(fit$p_hat[,1:(n_bulk/2)],b[,1:(n_bulk/2)])
```

```{r}
clusters01 = pam(R01,10)
folds01 = clusters01$clustering
table(folds01)
```



## Reduce cor fdr to 0.01

```{r}
cor.idx = readRDS('data/neuron/gene12400_cor_idx_alpha001.rds')
dim(cor.idx)
```


```{r}

# fit = estimation_func2(y=y,X=X,Vg=V,
#                        w=w,hc.type='hc3',correction=FALSE,
#                                              calc_cov=F,verbose=T,
#                                              cor.idx=cor.idx,
#                                              centeringXY=F,
#                                              true.beta = NULL,
#                                              only.scale.pos.res=F,
#                                              only.add.pos.res=T,
#                                              folds=NULL,
#                                              use_all_pair_for_cov=F)
# 
# saveRDS(fit,file='output/check_coverage_weight_neuron/11ref_hc3_alpha001_add_pos_res.rds')

fit = readRDS('output/check_coverage_weight_neuron/11ref_hc3_alpha001_add_pos_res.rds')

boxplot(t(fit$p_hat_se[,1:n_bulk/2]),ylim = range(c(fit$p_hat_se[,1:n_bulk/2],apply(fit$p_hat[,1:n_bulk/2],1,sd,na.rm=T)),na.rm = T),
        main = 'cor,cross validation')
lines(apply(fit$p_hat[,1:n_bulk/2],1,sd),type='p',col='yellow',pch=17)
legend('bottomright',c('true sd'),pch=17,col='yellow')

waldi = (fit$p_hat-b)/fit$p_hat_se

rowMeans(abs(waldi)<=1.96,na.rm = T)

rmse(fit$p_hat[,1:(n_bulk/2)],b[,1:(n_bulk/2)])
```


```{r}

# fit = estimation_func2(y=y,X=X,Vg=V,
#                        w=w,hc.type='jackknife',correction=FALSE,
#                                              calc_cov=F,verbose=T,
#                                              cor.idx=cor.idx,
#                                              centeringXY=F,
#                                              true.beta = NULL,
#                                              only.scale.pos.res=F,
#                                              only.add.pos.res=T,
#                                              folds=folds,
#                                              use_all_pair_for_cov=F)
# 
# saveRDS(fit,file='output/check_coverage_weight_neuron/11ref_jackknife_kmedoids_alpha001_add_pos_res.rds')

fit = readRDS('output/check_coverage_weight_neuron/11ref_jackknife_kmedoids_alpha001_add_pos_res.rds')

boxplot(t(fit$p_hat_se[,1:n_bulk/2]),ylim = range(c(fit$p_hat_se[,1:n_bulk/2],apply(fit$p_hat[,1:n_bulk/2],1,sd,na.rm=T)),na.rm = T),
        main = 'cor,cross validation')
lines(apply(fit$p_hat[,1:n_bulk/2],1,sd),type='p',col='yellow',pch=17)
legend('bottomright',c('true sd'),pch=17,col='yellow')

waldi = (fit$p_hat-b)/fit$p_hat_se

rowMeans(abs(waldi)<=1.96,na.rm = T)

rmse(fit$p_hat[,1:(n_bulk/2)],b[,1:(n_bulk/2)])

for(k in 1:6){
  print(rmse(fit$p_hat[k,1:(n_bulk/2)],b[k,1:(n_bulk/2)]))
}

```

