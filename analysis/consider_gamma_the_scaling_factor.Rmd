---
title: "consider gammaï¼Œ the_scaling_factor, in the simulation"
author: "DongyueXie"
date: "2021-08-21"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

## Introduction


Generate $X_j = U + E_j$, then scale each column of $X_j$ to sum to $G$.

```{r}
############## Run Simulation for manuscript ###############
source('code/deconference_main.R')
source('code/simulation/get_cor_pairs.R')


#'@description Generate data: based on real Xin data, generate uncorrelated or correlated individual reference matrices.
#'Compare methods: ols, adjust for measurement error, adjust for both measurement error and correlation, adjust for both measurement error and correlation and add weights.
#'For simplicity, we only simulate data at individual level. - only generate X from U;

#'@param ref population gene expression matrix U, of dimension G by K
#'@param b a K by n_bulk matrix of cell type proportions
#'@param R correlation matrix, sparse form
#'@param sigma2 biological variance matrix across individuals, of dimension G by K
#'@param alpha significance level of confidence interval
#'@param alpha.cor fdr level of detecting correlations
#'@param groups indicates two groups of bulk individual
#'@param n_bulk_for_cor number of bulk data generated for inferring correlations
simu_study     =   function(ref,
                            b,
                            R=NULL,
                            sigma2,
                            nreps = 100,
                            bulk_lib_size = 500,
                            n_ref = 10,
                            printevery=10,
                            verbose=FALSE,
                            alpha=0.05,
                            alpha.cor = 0.5,
                            groups = c(rep(1,ncol(b)/2),rep(2,ncol(b)/2)),
                            centeringXY = FALSE,
                            true.beta.for.Sigma=FALSE,
                            calc_cov = TRUE,
                            est_cor = TRUE,
                            only.scale.pos.res = FALSE,
                            only.add.pos.res = FALSE,
                            n_bulk_for_cor = 100,
                            cor_method = 'testing'){

  is.identity = function(X){
    if(!is.null(X)){
      (sum(X)==nrow(X))
    }else{
      FALSE
    }

  }

  genp = function(K){
    p = runif(K)
    p/sum(p)
  }

  G = nrow(ref)
  K = ncol(ref)
  n_bulk = ncol(b)
  b = apply(b,2,function(z){z/sum(z)})
  is.indep = (is.identity(R))|(is.null(R))


  # p_hat_ols = matrix(nrow=nreps,ncol=n_bulk*K)
  # p_hat_ols_se = matrix(nrow=nreps,ncol=n_bulk*K)
  #
  # p_hat = matrix(nrow=nreps,ncol=n_bulk*K)
  # p_hat_se = matrix(nrow=nreps,ncol=n_bulk*K)
  # p_hat_se_cor = matrix(nrow=nreps,ncol=n_bulk*K)
  #
  # p_hat_weight = matrix(nrow=nreps,ncol=n_bulk*K)
  # p_hat_weight_se_cor = matrix(nrow=nreps,ncol=n_bulk*K)

  p_hat_ols = array(dim = c(K,n_bulk,nreps))
  p_hat_ols_se = array(dim = c(K,n_bulk,nreps))

  p_hat = array(dim = c(K,n_bulk,nreps))
  p_hat_se = array(dim = c(K,n_bulk,nreps))
  p_hat_se_cor = array(dim = c(K,n_bulk,nreps))

  p_hat_weight = array(dim = c(K,n_bulk,nreps))
  p_hat_weight_se_cor = array(dim = c(K,n_bulk,nreps))

  diff_hat_ols = matrix(nrow=nreps,ncol=K)
  diff_hat_ols_se = matrix(nrow=nreps,ncol=K)

  diff_hat = matrix(nrow=nreps,ncol=K)
  diff_hat_se = matrix(nrow=nreps,ncol=K)
  diff_hat_se_cor = matrix(nrow=nreps,ncol=K)

  diff_hat_weight = matrix(nrow=nreps,ncol=K)
  diff_hat_weight_se_cor = matrix(nrow=nreps,ncol=K)


  gene_names = rownames(ref)
  true_betas = matrix(nrow=nreps,ncol=n_bulk*K)


  ## pre calculate MLN and generate independent normal

  norm.ref = matrix(nrow=G,ncol=K)
  norm.Sigma.chol = list()
  norm.Sigma = matrix(nrow=G,ncol=K)
  if(!is.indep){
    chol.R = chol(R)
  }
  for(k in 1:K){
    norm.ref[,k] = log(ref[,k]^2/sqrt(ref[,k]^2+sigma2[,k]))
    norm.s = sqrt(log(1+sigma2[,k]/ref[,k]^2))
    if(!is.indep){
      norm.Sigma.chol[[k]] = t(norm.s*t(chol.R))
    }else{
      norm.Sigma[,k] = norm.s^2
    }
  }


  if(!est_cor){
    if(!is.indep){
      cor.idx = which(R!=0,arr.ind = T)
      cor.idx = cor.idx[(cor.idx[,1]!=cor.idx[,2]),]
    }else{
      cor.idx = NULL
    }
  }else{

    X_array = array(dim=c(G,K,n_bulk_for_cor))
    for(k in 1:K){
      if(is.indep){
        X_array[,k,] = exp(matrix(rnorm(G*n_bulk_for_cor,norm.ref[,k],sqrt(norm.Sigma[,k])),ncol=n_bulk_for_cor))
      }else{
        X_array[,k,] = t(exp(mvnfast::rmvn(n_bulk_for_cor,mu = norm.ref[,k],sigma = norm.Sigma.chol[[k]],isChol = TRUE)))
      }
    }
    mb = apply(X_array,3,function(z){z%*%genp(K)})
    thetab = apply(mb,2,function(z){z/sum(z)})
    bulk_for_cor = matrix(rpois(G*n_bulk_for_cor,bulk_lib_size*G*thetab),nrow=G)
    rownames(bulk_for_cor) = gene_names
    cor.idx = get_cor_pairs2(bulk_for_cor,alpha=alpha.cor,method=cor_method)

  }

  all_fit = list()
  
  gammaj = matrix(nrow = nreps,ncol=n_ref)
  

  for(reps in 1:nreps){

    if(reps%%printevery==0){print(sprintf("running %d (out of %d)",reps,nreps))}

    # generate individual reference matrices

    n.temp = n_ref+n_bulk
    X_array = array(dim=c(G,K,n.temp))

    for(k in 1:K){
      if(is.indep){
        X_array[,k,] = exp(matrix(rnorm(G*n.temp,norm.ref[,k],sqrt(norm.Sigma[,k])),ncol=n.temp))
      }else{
        X_array[,k,] = t(exp(mvnfast::rmvn(n.temp,mu = norm.ref[,k],sigma = norm.Sigma.chol[[k]],isChol = TRUE)))
      }
    }

    #browser()

    X_array_bulk = X_array[,,1:n_bulk]

    X_array_ref = X_array[,,(n_bulk+1):(n_bulk+n_ref)]

    gammaj[reps,] = c(apply(X_array_ref,3,sum))
    
    
    ## scale X_ref
    for(indi in 1:n_ref){
      X_array_ref[,,indi] = apply(X_array_ref[,,indi],2,function(z){z/sum(z)*G})
    }
    



    mb = lapply(1:n_bulk,function(i){X_array_bulk[,,i]%*%b[,i]})
    mb = do.call(cbind,mb)
    true.beta = t(t(b)*c(apply(mb,2,function(z){bulk_lib_size*G/sum(z)})))
    true_betas[reps,] = c(true.beta)
    thetab = apply(mb,2,function(z){z/sum(z)})


    #browser()
    y = matrix(rpois(G*n_bulk,bulk_lib_size*G*thetab),nrow=G)
    rownames(y) = gene_names


    # fit model

    #browser()

    X = apply(X_array_ref,c(1,2),mean,na.rm=TRUE)
    V = t(apply(X_array_ref,c(1),function(z){(cov(t(z),use = 'complete.obs'))}))/n_ref



    fit.ols = ols_hc3(y,X,groups=groups)


    fit.err = estimation_func2(y=y,
                               X=X,
                               Vg=V,
                               w=1,
                               hc.type='hc3',
                               correction=FALSE,
                               calc_cov=calc_cov,
                               verbose=verbose,
                               cor.idx=NULL,
                               centeringXY=centeringXY,
                               true.beta = if(true.beta.for.Sigma){true.beta}else{NULL},
                               only.scale.pos.res=only.scale.pos.res,
                               only.add.pos.res=only.add.pos.res)

    fit.err.cor = estimation_func2(y=y,
                               X=X,
                               Vg=V,
                               w=1,
                               hc.type='hc3',
                               correction=FALSE,
                               calc_cov=calc_cov,
                               verbose=verbose,
                               cor.idx=cor.idx,
                               centeringXY=centeringXY,
                               true.beta = if(true.beta.for.Sigma){true.beta}else{NULL},
                               only.scale.pos.res=only.scale.pos.res,
                               only.add.pos.res=only.add.pos.res)

    fit.vash = vashr::vash(sqrt(rowSums(V)),df=n_ref-1)
    w = 1/(fit.vash$sd.post)^2
    fit.err.cor.weight = estimation_func2(y=y,
                                   X=X,
                                   Vg=V,
                                   w=w,
                                   hc.type='hc3',
                                   correction=FALSE,
                                   calc_cov=calc_cov,
                                   verbose=verbose,
                                   cor.idx=cor.idx,
                                   centeringXY=centeringXY,
                                   true.beta = if(true.beta.for.Sigma){true.beta}else{NULL},
                                   only.scale.pos.res=only.scale.pos.res,
                                   only.add.pos.res=only.add.pos.res)
#
#     temp = list()
#     temp[[1]] = fit.ols
#     temp[[2]] = fit.err
#     temp[[3]] = fit.err.cor
#     temp[[4]] = fit.err.cor.weight
#     all_fit[[reps]] = temp

    temp = list()
    temp$fit.ols =fit.ols
    temp$fit.err =fit.err
    temp$fit.err.cor = fit.err.cor
    temp$fit.err.cor.weight = fit.err.cor.weight
    all_fit[[reps]] = temp

    p_hat_ols[,,reps] = fit.ols$p_hat
    p_hat_ols_se[,,reps] = fit.ols$p_hat_se

    p_hat[,,reps] = fit.err$p_hat
    p_hat_se[,,reps] = fit.err$p_hat_se
    p_hat_se_cor[,,reps] = fit.err.cor$p_hat_se

    p_hat_weight[,,reps] = fit.err.cor.weight$p_hat
    p_hat_weight_se_cor[,,reps] = fit.err.cor.weight$p_hat_se


    diff_hat_ols[reps,] = fit.ols$diff_hat
    diff_hat_ols_se[reps,] = fit.ols$diff_hat_se

    diff_test = two_group_test(fit.err,groups)
    diff_hat[reps,] = c(diff_test$diff_group)
    diff_hat_se[reps,] = c(diff_test$diff_se)

    diff_test_cor = two_group_test(fit.err.cor,groups)
    diff_hat_se_cor[reps,] = c(diff_test_cor$diff_se)

    diff_test_cor_weight = two_group_test(fit.err.cor.weight,groups)
    diff_hat_weight[reps,] = c(diff_test_cor_weight$diff_group)
    diff_hat_weight_se_cor[reps,] = c(diff_test_cor_weight$diff_se)

  }

  return(list(p_hat_ols = p_hat_ols,
              p_hat_ols_se = p_hat_ols_se,

              p_hat = p_hat,
              p_hat_se = p_hat_se,
              p_hat_se_cor = p_hat_se_cor,

              p_hat_weight = p_hat_weight,
              p_hat_weight_se_cor = p_hat_weight_se_cor,

              diff_hat_ols = diff_hat_ols,
              diff_hat_ols_se = diff_hat_ols_se,

              diff_hat = diff_hat,
              diff_hat_se = diff_hat_se,
              diff_hat_se_cor = diff_hat_se_cor,

              diff_hat_weight = diff_hat_weight,
              diff_hat_weight_se_cor = diff_hat_weight_se_cor,
              gammaj=gammaj,
              input = list(b=b,groups=groups),
              all_fit=all_fit))





}

calc_ci = function(b,V,alpha=0.05,eps=1e-7,logit=TRUE){
  if(logit){
    b = b+eps
    b.temp = log(b/(1-b))
    J = diag(1/(b*(1-b)))
    V.temp = J%*%V%*%J
    ci.l = b.temp-qnorm(1-alpha/2)*sqrt(diag(V.temp))
    ci.r = b.temp+qnorm(1-alpha/2)*sqrt(diag(V.temp))
    return(cbind(1/(1+exp(-ci.l)),1/(1+exp(-ci.r))))
  }else{
    ci.l = b-qnorm(1-alpha/2)*sqrt(diag(V))
    ci.r = b+qnorm(1-alpha/2)*sqrt(diag(V))
    return(cbind(ci.l,ci.r))
  }

}


ols_hc3 = function(y,X,w=NULL,groups=NULL){
  G = nrow(X)
  K = ncol(X)
  y = cbind(y)
  nb = ncol(y)

  if(!is.null(groups)){
    if(is.factor(groups)){
      group_name = levels(groups)
    }else{
      group_name = levels(as.factor(groups))
    }

    group1_idx = which(groups==group_name[1])
    a = c()
    a[group1_idx] = 1/length(group1_idx)

    group2_idx = which(groups==group_name[2])
    a[group2_idx] = -1/length(group2_idx)
  }

  if(is.null(w)){
    w  = rep(1,G)
  }
  w = w/sum(w)*G

  Xw = X*sqrt(w)
  yw = cbind(y*sqrt(w))
  A = t(Xw)%*%Xw
  A_inv = solve(A)

  beta_hat = pmax(A_inv%*%t(Xw)%*%yw,0)
  beta_hat = cbind(beta_hat)
  p_hat = apply(beta_hat,2,function(z){z/sum(z)})
  rownames(p_hat) = colnames(X)
  rownames(beta_hat) = colnames(X)
  res = yw - Xw%*%beta_hat

  J = matrix(0,nrow=(nb*K),ncol=(nb*K))
  for(i in 1:nb){
    J[((i-1)*K+1):(i*K),((i-1)*K+1):(i*K)] = J_sum2one(beta_hat[,i],K)
  }




  Sigma = matrix(0,nrow=nb*K,ncol=nb*K)
  Q_inv = matrix(0,nrow=nb*K,ncol=nb*K)
  Sigma_ii = matrix(0,nrow=nb*K,ncol=nb*K)

  for(i in 1:nb){
    Q_inv[((i-1)*K+1):(i*K),((i-1)*K+1):(i*K)] = A_inv

    #Hi = t(t(X%*%A_inv%*%t(X))*w)
    #hi = diag(Hi)


    h = rowSums((X%*%A_inv)*X)*w
    ri = res[,i]

    for(j in i:nb){

      if(j==i){

        Sigma_ij = crossprod(c(ri)/(1-pmax(pmin(h,1-1/G),0))*w*X)

        Sigma_ii[((i-1)*K+1):(i*K),((i-1)*K+1):(i*K)] = Sigma_ij
      }else{

        rj = res[,j]

        Sigma_ij = crossprod(c(ri)/(1-pmax(pmin(h,1-1/G),0))*w*X,
                             c(rj)/(1-pmax(pmin(h,1-1/G),0))*w*X)
      }


      Sigma[((i-1)*K+1):(i*K),((j-1)*K+1):(j*K)] = Sigma_ij

    }
  }
  Sigma = Sigma+t(Sigma)-Sigma_ii
  covb = Q_inv%*%Sigma%*%Q_inv

  asyV = (J)%*%covb%*%t(J)


  p_hat_se = sqrt(diag(asyV))
  p_hat_se = matrix(p_hat_se,ncol=nb)

  if(!is.null(groups)){

    V_tilde = 0

    idx = c(group1_idx,group2_idx)
    for(i in idx){
      for(j in idx){
        V_tilde = V_tilde + a[i]*a[j]*asyV[((i-1)*K+1):(i*K),((j-1)*K+1):(j*K)]
      }
    }

    diff_hat = rowMeans(p_hat[,group1_idx,drop=F]) - rowMeans(p_hat[,group2_idx,drop=F])
    z_score = diff_hat/sqrt(diag(V_tilde))

    p_value = (1-pnorm(abs(z_score)))*2


  }


  return(list(p_hat=p_hat,
              p_hat_se = p_hat_se,
              diff_hat=diff_hat,
              diff_hat_se = sqrt(diag(V_tilde)),
              diff_z_score=z_score,
              diff_p_value=p_value))




}




```

```{r}
xin_raw <- readRDS("data/pancreas/xin_raw.rds")
cell_types = c('alpha', 'beta', 'delta', 'gamma')
K = length(cell_types)
rm.indi = c("Non T2D 4","Non T2D 7","Non T2D 10","Non T2D 12")
rm.indi.idx = which(xin_raw$individual%in%rm.indi)

datax.xin = set_data_decon(Y = xin_raw[,-rm.indi.idx],cell_types = cell_types,
                           gene_thresh = 0.05,max_count_quantile_celltype = 0.95,
                           max_count_quantile_indi = 0.95,
                           w=1)
design.mat.xin = scRef_multi_proc(datax.xin$Y,datax.xin$cell_type_idx,
                                  datax.xin$indi_idx,estimator="separate",
                                  est_sigma2 = TRUE,meta_mode = 'local',smooth.sigma = F)

ref = design.mat.xin$X
sigma2 = design.mat.xin$Sigma

ref = ref+1/nrow(ref)
sigma2 = sigma2 + 1/nrow(ref)

G = nrow(ref)
ref = ref/sum(ref)*K*G

b1 = c(0.1,0.1,0.3,0.5)
b2 = c(0.1,0.15,0.4,0.35)
nb = 10
b = cbind(b1%*%t(rep(1,nb/2)),b2%*%t(rep(1,nb/2)))

# G = nrow(ref)
# K = 4
# d = 500
# A = matrix(0,nrow=G,ncol=G)
# 
# for(i in 1:G){
#   for(j in i:min(i+d,G)){
#     A[i,j] = max(1-abs(i-j)/d,0)
#   }
# }
# A = A+t(A) - diag(G)
# library(Matrix)
# A = Matrix(A,sparse = TRUE)
# 
# set.seed(12345)
# simu_out = simu_study(ref,b,R=A,sigma2,printevery = 1)
# saveRDS(simu_out,file = 'output/manuscript/simulation_10bulk_500genecor_fdr05_gammaj.rds')
# 
# 
# set.seed(12345)
# simu_out = simu_study(ref,b,R=NULL,sigma2,printevery = 1)
# saveRDS(simu_out,file = 'output/manuscript/simulation_10bulk_0genecor_fdr05_gammaj.rds')
```


```{r}
get_rmse = function(p_hat,b){
  K = dim(p_hat)[1]
  nb = dim(p_hat)[2]
  nreps = dim(p_hat)[3]
  rmses = c()
  for(i in 1:nb){
    err = c()
    for(j in 1:nreps){
      err[j] = sum((p_hat[,i,j]-b[,i])^2)
    }
    rmses[i] = sqrt(mean(err))
  }
  names(rmses) = paste('bulk',1:nb)
  round(rmses,3)

}

get_coverage_p = function(p_hat,p_hat_se,b){

  K = dim(p_hat)[1]
  nb = dim(p_hat)[2]
  z = array(dim = dim(p_hat))
  for(i in 1:dim(z)[3]){
    z[,,i] = (p_hat[,,i]-b)/p_hat_se[,,i]
  }
  crg = apply(z,c(1,2),function(z){round(mean(abs(z)<1.96,na.rm=T),3)})
  rownames(crg) = paste('cell',1:K)
  colnames(crg) = paste('bulk',1:nb)
  crg
}

get_power_diff = function(diff_hat,diff_hat_se){
  colMeans(abs(diff_hat/diff_hat_se)>1.96,na.rm=TRUE)
}

```




## correlated gene 500

In the first case, each gene is correlated with 500 other genes via a banded correlation matrix. 100 bulk data are generated for inferring the correlated gene pairs and a fdr level 0.5 was used.

```{r}
simu_out = readRDS('output/manuscript/simulation_10bulk_500genecor_fdr05_gammaj.rds')
```

```{r, results = 'asis'}
rmse_out = rbind(get_rmse(simu_out$p_hat_ols,b),
get_rmse(simu_out$p_hat,b),
get_rmse(simu_out$p_hat_weight,b))
rownames(rmse_out) = c('ols','m.err.adj','m.err.adj.weighted')
knitr::kable(rmse_out,caption='rooted mean sqaured errors')
```

```{r, results = 'asis'}
knitr::kable(get_coverage_p(simu_out$p_hat_ols,simu_out$p_hat_ols_se,b),caption='ols')
knitr::kable(get_coverage_p(simu_out$p_hat,simu_out$p_hat_se,b),caption='m.err.adj')
knitr::kable(get_coverage_p(simu_out$p_hat,simu_out$p_hat_se_cor,b),caption='m.err.cor.adj')
knitr::kable(get_coverage_p(simu_out$p_hat_weight,simu_out$p_hat_weight_se_cor,b),caption='m.err.cor.adj.weighted')
```

```{r, results = 'asis'}
test = rbind(get_power_diff(simu_out$diff_hat_ols,simu_out$diff_hat_ols_se),
get_power_diff(simu_out$diff_hat,simu_out$diff_hat_se),
get_power_diff(simu_out$diff_hat,simu_out$diff_hat_se_cor),
get_power_diff(simu_out$diff_hat_weight,simu_out$diff_hat_weight_se_cor))
rownames(test) = c('ols','m.err.adj','m.err.cor.adj','m.err.cor.adj.weighted')
colnames(test) = c('type 1 error','power','power','power')
knitr::kable(test)
```

```{r}
simu_out$gammaj[1:10,]/K/G
```

## correlated gene 0

No correlation is presented. 100 bulk data are generated for inferring the correlated gene pairs and a fdr level 0.5 was used.

```{r}
simu_out = readRDS('output/manuscript/simulation_10bulk_0genecor_fdr05_gammaj.rds')
```

```{r, results = 'asis'}
rmse_out = rbind(get_rmse(simu_out$p_hat_ols,b),
get_rmse(simu_out$p_hat,b),
get_rmse(simu_out$p_hat_weight,b))
rownames(rmse_out) = c('ols','m.err.adj','m.err.adj.weighted')
knitr::kable(rmse_out,caption='rooted mean sqaured errors')
```

```{r, results = 'asis'}
knitr::kable(get_coverage_p(simu_out$p_hat_ols,simu_out$p_hat_ols_se,b),caption='ols')
knitr::kable(get_coverage_p(simu_out$p_hat,simu_out$p_hat_se,b),caption='m.err.adj')
knitr::kable(get_coverage_p(simu_out$p_hat,simu_out$p_hat_se_cor,b),caption='m.err.cor.adj')
knitr::kable(get_coverage_p(simu_out$p_hat_weight,simu_out$p_hat_weight_se_cor,b),caption='m.err.cor.adj.weighted')
```

```{r, results = 'asis'}
test = rbind(get_power_diff(simu_out$diff_hat_ols,simu_out$diff_hat_ols_se),
get_power_diff(simu_out$diff_hat,simu_out$diff_hat_se),
get_power_diff(simu_out$diff_hat,simu_out$diff_hat_se_cor),
get_power_diff(simu_out$diff_hat_weight,simu_out$diff_hat_weight_se_cor))
rownames(test) = c('ols','m.err.adj','m.err.cor.adj','m.err.cor.adj.weighted')
colnames(test) = c('type 1 error','power','power','power')
knitr::kable(test)
```


